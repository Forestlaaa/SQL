# This file is for leetcode SQL, mySQL
# Mostly the upper part code is written by myself, the lower part code is the official solution.

# 183. Customers Who Never Order

Select c.name AS customers
From Customers c left join Orders o
on c.id = o.customerId
where o.customerId is NULL

select customers.name as 'Customers'
from customers
where customers.id not in
(
    select customerid from orders  # !Never write such things before in SQLite
);

# 1873. Calculate Special Bonus
# Write an SQL query to calculate the bonus of each employee. The bonus of an employee is 100% of their salary if the ID of the employee is an odd number 
# and the employee name does not start with the character 'M'. The bonus of an employee is 0 otherwise.
# Return the result table ordered by employee_id.

SELECT employee_id
,case
    WHEN employee_id % 2 <> 0 AND substr(name, 1, 1) <> "M" THEN salary
    Else 0
END bonus
From Employees
Order by employee_id ASC

select employee_id , salary * ( employee_id%2 ) * ( name not like 'M%') as bonus  # !Use wildcard 
from employees
order by employee_id;

# update: 627. Swap Salary
UPDATE Salary 
set
    sex = case sex
        when "m" then "f"
        else "m"
        end;
        
# !!!DELETE 196. Delete Duplicate Emails:  delete all the duplicate emails, keeping only one unique email with the smallest id.
## Use self join

DELETE a from Person a
    , Person b
Where a.email = b.email AND a.id > b.id

DELETE FROM Person WHERE Id NOT IN 
(SELECT * FROM(
    SELECT MIN(Id) FROM Person GROUP BY Email) as p);
 
# !!!182. Duplicate Emails

Select email
from Person
Group by email
HAVING COUNT(email)>1 
    
# 1667. Fix Names in a Table: Write an SQL query to fix the names so that only the first character is uppercase and the rest are lowercase.
## Pay attention: In Mysql, concatenate use function concat(), while in sqlite, use ||, in SQL server, use "+"

Select user_id
, concat(Upper(substr(name, 1, 1)), Lower(substr(name, 2))) AS name
From Users
Order by user_id ASC


# !!!1484. Group Sold Products By The Date: Write an SQL query to find for each date the number of different products sold and their names.
# The sold products names for each date should be sorted lexicographically.
# Return the result table ordered by sell_date.

## Points: 1. Use DISTINCT  2. use Group_concat to concatenate the values from multiple rows into a single string and returns it.
## Syntax:
GROUP_CONCAT(DISTINCT expression
    ORDER BY expression
    SEPARATOR sep);

## code
Select sell_date
, count(DISTINCT product) AS num_sold
, Group_concat(DISTINCT product 
        order by product ASC
        separator ',' ) as products
From Activities
Group by sell_date
Order by sell_date


# !!!Wildcard
# From W3School
Symbol	Description	                                                Example
%	    Represents zero or more characters	                        bl% finds bl, black, blue, and blob
_	    Represents a single character	                            h_t finds hot, hat, and hit
[]	    Represents any single character within the brackets	        h[oa]t finds hot and hat, but not hit
^	    Represents any character not in the brackets	            h[^oa]t finds hit, but not hot and hat
-	    Represents any single character within the specified range	c[a-b]t finds cat and cbt

LIKE  Operator	                Description
WHERE CustomerName LIKE 'a%'	Finds any values that starts with "a"
WHERE CustomerName LIKE '%a'	Finds any values that ends with "a"
WHERE CustomerName LIKE '%or%'	Finds any values that have "or" in any position
WHERE CustomerName LIKE '_r%'	Finds any values that have "r" in the second position
WHERE CustomerName LIKE 'a__%'	Finds any values that starts with "a" and are at least 3 characters in length
WHERE ContactName LIKE 'a%o'	Finds any values that starts with "a" and ends with "o"

### Solution1:
select patient_id, patient_name, conditions
From Patients
Where conditions LIKE 'DIAB1%' OR conditions LIKE '% DIAB1%'

### Solution2: Use REGEXP
SELECT * FROM patients WHERE conditions REGEXP '\\bDIAB1'


# !!!1965. Employees With Missing Information:  
            report the IDs of all the employees with missing information. The information of an employee is missing if:
            The employee's name is missing, or
            The employee's salary is missing.
            Return the result table ordered by employee_id in ascending order.

### Solution1: Use LEFT JOIN and RIGHT JOIN to realize full join in Mysql
### Pay attention: 1.If column names of two tables are identical, use the USING clause instead of the ON clause

Select employee_id
From (select * from Employees E left join Salaries S using(employee_id)
    UNION
    select * from Employees E right join Salaries S using(employee_id)) AS A
Where A.name IS NULL or A.salary IS NULL
Order by employee_id ASC

### Solution2 : Use NOT IN 

SELECT employee_id
FROM Employees
WHERE employee_id NOT IN (SELECT employee_id
                          FROM Salaries)
UNION
SELECT employee_id
FROM Salaries
WHERE employee_id NOT IN (SELECT employee_id
                          FROM Employees)
ORDER BY employee_id;

# !!!1795. Rearrange Products Table
### Solution1: In Mysql, use union

SELECT product_id, 'store1' AS store, store1 AS price 
FROM Products 
WHERE store1 IS NOT NULL
UNION 
SELECT product_id, 'store2' AS store, store2 AS price 
FROM Products 
WHERE store2 IS NOT NULL
UNION 
SELECT product_id, 'store3' AS store, store3 AS price 
FROM Products 
WHERE store3 IS NOT NULL

### Solution2: In MS Sql Server, use UNIPIVOT

SELECT product_id , store , price
FROM Products
UNPIVOT
(
price
FOR store in (store1, store2, store3)
) AS Products_Unpivoted


# !!!608. Tree Node: Write an SQL query to report the type of each node in the tree. Return the result table ordered by id in ascending order.
Tree table:
+----+------+
| id | p_id |
+----+------+
| 1  | null |
| 2  | 1    |
| 3  | 1    |
| 4  | 2    |
| 5  | 2    |
+----+------+
## Consider clearly before quering. The solutions are almost the same but using different snytax

### Solution1: use case when 

Select id,
case 
    when p_id is null then "Root"
    when id not in (
        select DISTINCT p_id
        from Tree
        Where p_id is not null
    ) then "Leaf"
    else "Inner"
end AS type
From Tree
Order by id ASC

### Solution2: use if function

Select id
, if(isnull(id), "Root",
        if(id in (select DINTINCT p_id From Tree), 'Inner', 'Leaf')) Type
From Tree
Order by id ASC

1393. Capital Gain/Loss: Write an SQL query to report the Capital gain/loss for each stock.
+---------------+-----------+---------------+--------+
| stock_name    | operation | operation_day | price  |
+---------------+-----------+---------------+--------+
| Leetcode      | Buy       | 1             | 1000   |
| Corona Masks  | Buy       | 2             | 10     |
| Leetcode      | Sell      | 5             | 9000   |
| Handbags      | Buy       | 17            | 30000  |
| Corona Masks  | Sell      | 3             | 1010   |
| Corona Masks  | Buy       | 4             | 1000   |
| Corona Masks  | Sell      | 5             | 500    |
| Corona Masks  | Buy       | 6             | 1000   |
| Handbags      | Sell      | 29            | 7000   |
| Corona Masks  | Sell      | 10            | 10000  |
+---------------+-----------+---------------+--------+

### Solution1: use if function, always forget this function...

SELECT stock_name, SUM(IF(operation = "Buy", price*-1, price*1) ) AS capital_gain_loss
FROM Stocks
GROUP BY Stock_name

### Solution2: use case when
Select stock_name
, sum((case operation
    when 'Buy' then -1
    else 1
    END) * price) as capital_gain_loss
From Stocks
Group by Stock_name

# !!!176. Second Highest Salary: Write an SQL query to report the second highest salary from the Employee table. 
# If there is no second highest salary, the query should report null

### Solution1 : To get the second largest salary, first use DISTINCT to avoid duplicate value, then use LIMIT OFFSET syntax
### 当limit后面跟两个参数的时候，第一个数表示要跳过的数量，后一位表示要取的数量;
### 当limit后面跟一个参数的时候，该参数表示要取的数据的数量;
### 当limit和offset组合使用的时候，limit后面只能有一个参数，表示要取的的数量,offset表示要跳过的数量。

SELECT
    (SELECT DISTINCT Salary
        FROM Employee
        ORDER BY Salary DESC
        LIMIT 1 OFFSET 1) AS SecondHighestSalary
        

### Solution2: The second largest is the largest number among the rest values without the largest value

select MAX(Salary) As SecondHighestSalary
from Employee
Where Salary < (select max(Salary) From Employee)

# !!!586. Customer Placing the Largest Number of Orders: Write an SQL query to find the customer_number for the customer who has placed the largest number of orders.
+--------------+-----------------+
| order_number | customer_number |
+--------------+-----------------+
| 1            | 1               |
| 2            | 2               |
| 3            | 3               |
| 4            | 3               |
+--------------+-----------------+
## How to get the max(sum(order_number))?
### Solution1: use limit

Select customer_number
From Orders
Group by customer_number
Order by COUNT(*) DESC
LIMIT 1

### Solution2: 
select customer_number from orders
group by customer_number
having count(order_number) = 
(
select max(count) from 
    ( 
     select count(order_number) as count from orders group by customer_number
     ) sub1
)

### Solution3: use ALL()
select customer_number from orders 
group by customer_number
having count(customer_number) >= all 
(select count(customer_number) from orders group by customer_number)


# 1581. Customer Who Visited but Did Not Make Any Transactions
## My main problems now is that while writing, my thinking is not very clear; and also sometimes I don't know how to write snytax

Select DISTINCT customer_id, 
COUNT(customer_id) AS count_no_trans
From Visits
Where visit_id not in
    (select T.visit_id
    From Transactions T left join Visits V on T.visit_id = V.visit_id)              
Group by customer_id
Order by count_no_trans DESC

SELECT customer_id, COUNT(v.visit_id) as count_no_trans 
FROM Visits v
LEFT JOIN Transactions t ON v.visit_id = t.visit_id
WHERE transaction_id IS NULL
GROUP BY customer_id


# 1148. Article Views I: Write an SQL query to find all the authors that viewed at least one of their own articles.

SELECT DISTINCT(author_id) AS id 
FROM Views WHERE author_id = viewer_id 
ORDER BY id ASC;

#在使用 left join 时，on 和 where 条件的区别如下：
#1、on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。
#2、where 条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有 left join 的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。

# !!!197. Rising Temperature: Write an SQL query to find all dates' Id with higher temperatures compared to its previous dates (yesterday).
Weather Table
+----+------------+-------------+
| id | recordDate | temperature |
+----+------------+-------------+
| 1  | 2015-01-01 | 10          |
| 2  | 2015-01-02 | 25          |
| 3  | 2015-01-03 | 20          |
| 4  | 2015-01-04 | 30          |
+----+------------+-------------+

## The point is using self join and datediff() or subdate() function. Before I know the two function, I even tried to insert and update and then compare, but it doesn't work. I don't know where is wrong

### Solution1
SELECT w2.id from Weather w1,Weather w2
WHERE datediff(w2.recordDate, w1.recordDate) = 1 AND w2.temperature > w1.temperature;
// where datediff -> date difference b/w two dates

### Solution2
SELECT w2.id from Weather w1, Weather w2
WHERE w2.temperature > w1.temperature AND
subdate(w2.recordDate, 1) = w1.recordDate;
// where subdate -> subtract date 


# 607. Sales Person

Select name
From SalesPerson
Where sales_id not in (
    Select O.sales_id
    from Orders O left join Company C
    On O.com_id = C.com_id
    Where C.name = "RED"
)


# !!!1141. User Activity for the Past 30 Days I: Write an SQL query to find the daily active user count for a period of 30 days ending 2019-07-27 inclusively. 
# A user was active on someday if they made at least one activity on that day.
## Use datediff() and group by 

Select activity_date as day
, count(DISTINCT user_id) as active_users
From Activity
Where (activity_date between '2019-06-28' AND '2019-07-27')  
Group by activity_date

SELECT activity_date as day, COUNT(DISTINCT user_id) as active_users
FROM Activity
WHERE datediff('2019-07-27',activity_date)<30 
GROUP BY activity_date

# !!!511. Game Play Analysis I: Write an SQL query to report the first login date for each player.
+-----------+-----------+------------+--------------+
| player_id | device_id | event_date | games_played |
+-----------+-----------+------------+--------------+
| 1         | 2         | 2016-03-01 | 5            |
| 1         | 2         | 2016-05-02 | 6            |
| 2         | 3         | 2017-06-25 | 1            |
| 3         | 1         | 2016-03-02 | 0            |
| 3         | 4         | 2018-07-03 | 5            |
+-----------+-----------+------------+--------------+

## Window function: RANK(), DENSE_RANK(), or ROW_NUMBER()
### Solution1: use ROW_NUMBER() OVER(PARTITION BY column1 ORDER BY column2) as new_index, the result shows the rank in a group; then use condition new_index = 1 to query the first record of a group

select player_id, event_date as first_login
from (select player_id, event_date
, ROW_NUMBER() over(partition by player_id order by event_date) as new_index
from Activity) t
where t.new_index = 1

### Solution2: use FIRST_VALUE() window function

SELECT DISTINCT
  A.player_id,
  FIRST_VALUE(A.event_date) OVER (
    PARTITION BY
      A.player_id
    ORDER BY
      A.event_date
  ) AS first_login
FROM
  Activity A;

### Solution3: min() can work...
select player_id, 
min(event_date) as first_login
From Activity
Group by player_id

#1890. The Latest Login in 2020: Write an SQL query to report the latest login for all users in the year 2020. Do not include the users who did not login in 2020.

### Solution1: use max() and year()
Select user_id, 
max(time_stamp) as last_stamp
from Logins
where year(time_stamp) = 2020 
Group by user_id

### Solution2: use window function LAST_VALUE()
Select DISTINCT user_id, 
LAST_VALUE(time_stamp) OVER(
    PARTITION BY user_id
    ORDER BY time_stamp ASC
    RANGE BETWEEN 
            UNBOUNDED PRECEDING AND 
            UNBOUNDED FOLLOWING
) as last_stamp
from Logins
Where year(time_stamp) = 2020

# !1407. Top Travellers: Write an SQL query to report the distance traveled by each user.

## ifnull can change null value into 0
Select u.name, ifnull(sum(r.distance), 0) as travelled_distance
From Users u left join Rides r
on u.id = r.user_id
group by r.user_id
order by travelled_distance DESC, name ASC

# !1158. Market Analysis I: Write an SQL query to find for each user, the join date and the number of orders they made as a buyer in 2019.

## 只用对应buyer_id
SELECT u.user_id AS buyer_id, join_date, COUNT(order_date) AS orders_in_2019 
FROM Users as u
LEFT JOIN Orders as o
ON u.user_id = o.buyer_id
AND YEAR(order_date) = '2019'
GROUP BY u.user_id


# !1050. Actors and Directors Who Cooperated At Least Three Times
## Study the from clause in this chunk of code below

select actor_id, director_id 
from(
select actor_id,director_id, 
count(timestamp) as cooperated 
from ActorDirector 
group by actor_id,director_id) 
table1
where cooperated>=3;

Select actor_id, director_id
from ActorDirector
Group by actor_id, director_id
Having count(timestamp) >= 3


#1084. Sales Analysis III: Write an SQL query that reports the products that were only sold in the first quarter of 2019. That is, between 2019-01-01 and 2019-03-31 inclusive.

## Use group by to get rid of product_id that appear several times
Select S.product_id, P.product_name
From Sales S left join Product P
on S.product_id = P.product_id
Group by S.product_id
Having S.product_id not in(
    select product_id
    from Sales
    Where sale_date not between '2019-01-01' AND '2019-03-31')
