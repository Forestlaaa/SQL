# This file is for leetcode SQL, mySQL
# Mostly the upper part code is written by myself, the lower part code is the official solution.

# 183. Customers Who Never Order

Select c.name AS customers
From Customers c left join Orders o
on c.id = o.customerId
where o.customerId is NULL

select customers.name as 'Customers'
from customers
where customers.id not in
(
    select customerid from orders  # !Never write such things before in SQLite
);

# 1873. Calculate Special Bonus
# Write an SQL query to calculate the bonus of each employee. The bonus of an employee is 100% of their salary if the ID of the employee is an odd number 
# and the employee name does not start with the character 'M'. The bonus of an employee is 0 otherwise.
# Return the result table ordered by employee_id.

SELECT employee_id
,case
    WHEN employee_id % 2 <> 0 AND substr(name, 1, 1) <> "M" THEN salary
    Else 0
END bonus
From Employees
Order by employee_id ASC

select employee_id , salary * ( employee_id%2 ) * ( name not like 'M%') as bonus  # !Use wildcard 
from employees
order by employee_id;

# update: 627. Swap Salary
UPDATE Salary 
set
    sex = case sex
        when "m" then "f"
        else "m"
        end;
        
# !!!DELETE 196. Delete Duplicate Emails:  delete all the duplicate emails, keeping only one unique email with the smallest id.
## Use self join

DELETE a from Person a
    , Person b
Where a.email = b.email AND a.id > b.id

DELETE FROM Person WHERE Id NOT IN 
(SELECT * FROM(
    SELECT MIN(Id) FROM Person GROUP BY Email) as p);
    
    
# 1667. Fix Names in a Table: Write an SQL query to fix the names so that only the first character is uppercase and the rest are lowercase.
## Pay attention: In Mysql, concatenate use function concat(), while in sqlite, use ||, in SQL server, use "+"

Select user_id
, concat(Upper(substr(name, 1, 1)), Lower(substr(name, 2))) AS name
From Users
Order by user_id ASC


# !!!1484. Group Sold Products By The Date: Write an SQL query to find for each date the number of different products sold and their names.
# The sold products names for each date should be sorted lexicographically.
# Return the result table ordered by sell_date.

## Points: 1. Use DISTINCT  2. use Group_concat to concatenate the values from multiple rows into a single string and returns it.
## Syntax:
GROUP_CONCAT(DISTINCT expression
    ORDER BY expression
    SEPARATOR sep);

## code
Select sell_date
, count(DISTINCT product) AS num_sold
, Group_concat(DISTINCT product 
        order by product ASC
        separator ',' ) as products
From Activities
Group by sell_date
Order by sell_date


# !!!Wildcard
# From W3School
Symbol	Description	                                                Example
%	    Represents zero or more characters	                        bl% finds bl, black, blue, and blob
_	    Represents a single character	                            h_t finds hot, hat, and hit
[]	    Represents any single character within the brackets	        h[oa]t finds hot and hat, but not hit
^	    Represents any character not in the brackets	            h[^oa]t finds hit, but not hot and hat
-	    Represents any single character within the specified range	c[a-b]t finds cat and cbt

LIKE  Operator	                Description
WHERE CustomerName LIKE 'a%'	Finds any values that starts with "a"
WHERE CustomerName LIKE '%a'	Finds any values that ends with "a"
WHERE CustomerName LIKE '%or%'	Finds any values that have "or" in any position
WHERE CustomerName LIKE '_r%'	Finds any values that have "r" in the second position
WHERE CustomerName LIKE 'a__%'	Finds any values that starts with "a" and are at least 3 characters in length
WHERE ContactName LIKE 'a%o'	Finds any values that starts with "a" and ends with "o"

### Solution1:
select patient_id, patient_name, conditions
From Patients
Where conditions LIKE 'DIAB1%' OR conditions LIKE '% DIAB1%'

### Solution2: Use REGEXP
SELECT * FROM patients WHERE conditions REGEXP '\\bDIAB1'


# !!!1965. Employees With Missing Information:  
            report the IDs of all the employees with missing information. The information of an employee is missing if:
            The employee's name is missing, or
            The employee's salary is missing.
            Return the result table ordered by employee_id in ascending order.

### Solution1: Use LEFT JOIN and RIGHT JOIN to realize full join in Mysql
### Pay attention: 1.If column names of two tables are identical, use the USING clause instead of the ON clause

Select employee_id
From (select * from Employees E left join Salaries S using(employee_id)
    UNION
    select * from Employees E right join Salaries S using(employee_id)) AS A
Where A.name IS NULL or A.salary IS NULL
Order by employee_id ASC

### Solution2 : Use NOT IN 

SELECT employee_id
FROM Employees
WHERE employee_id NOT IN (SELECT employee_id
                          FROM Salaries)
UNION
SELECT employee_id
FROM Salaries
WHERE employee_id NOT IN (SELECT employee_id
                          FROM Employees)
ORDER BY employee_id;

# !!!1795. Rearrange Products Table
### Solution1: In Mysql, use union

SELECT product_id, 'store1' AS store, store1 AS price 
FROM Products 
WHERE store1 IS NOT NULL
UNION 
SELECT product_id, 'store2' AS store, store2 AS price 
FROM Products 
WHERE store2 IS NOT NULL
UNION 
SELECT product_id, 'store3' AS store, store3 AS price 
FROM Products 
WHERE store3 IS NOT NULL

### Solution2: In MS Sql Server, use UNIPIVOT

SELECT product_id , store , price
FROM Products
UNPIVOT
(
price
FOR store in (store1, store2, store3)
) AS Products_Unpivoted


# !!!608. Tree Node: Write an SQL query to report the type of each node in the tree. Return the result table ordered by id in ascending order.
Tree table:
+----+------+
| id | p_id |
+----+------+
| 1  | null |
| 2  | 1    |
| 3  | 1    |
| 4  | 2    |
| 5  | 2    |
+----+------+
## Consider clearly before quering. The solutions are almost the same but using different snytax

### Solution1: use case when 

Select id,
case 
    when p_id is null then "Root"
    when id not in (
        select DISTINCT p_id
        from Tree
        Where p_id is not null
    ) then "Leaf"
    else "Inner"
end AS type
From Tree
Order by id ASC

### Solution2: use if function

Select id
, if(isnull(id), "Root",
        if(id in (select DINTINCT p_id From Tree), 'Inner', 'Leaf')) Type
From Tree
Order by id ASC


# !!!176. Second Highest Salary: Write an SQL query to report the second highest salary from the Employee table. 
# If there is no second highest salary, the query should report null

### Solution1 : To get the second largest salary, first use DISTINCTto avoid duplicate value, then use LIMIT OFFSET syntax
### 当limit后面跟两个参数的时候，第一个数表示要跳过的数量，后一位表示要取的数量;
### 当limit后面跟一个参数的时候，该参数表示要取的数据的数量;
### 当limit和offset组合使用的时候，limit后面只能有一个参数，表示要取的的数量,offset表示要跳过的数量。

SELECT
    (SELECT DISTINCT Salary
        FROM Employee
        ORDER BY Salary DESC
        LIMIT 1 OFFSET 1) AS SecondHighestSalary
        

### Solution2: The second largest is the largest number among the rest values without the largest value

select MAX(Salary) As SecondHighestSalary
from Employee
Where Salary < (select max(Salary) From Employee)


# 1581. Customer Who Visited but Did Not Make Any Transactions
## My main problems now is that while writing, my thinking is not very clear; and also sometimes I don't know how to write snytax

Select DISTINCT customer_id, 
COUNT(customer_id) AS count_no_trans
From Visits
Where visit_id not in
    (select T.visit_id
    From Transactions T left join Visits V on T.visit_id = V.visit_id)              
Group by customer_id
Order by count_no_trans DESC

SELECT customer_id, COUNT(v.visit_id) as count_no_trans 
FROM Visits v
LEFT JOIN Transactions t ON v.visit_id = t.visit_id
WHERE transaction_id IS NULL
GROUP BY customer_id






















